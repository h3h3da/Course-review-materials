# 公钥密码

## 公钥密码的基本思想

### 传统密码的优缺点
1. 优点
```
理论和实践都很成熟
安全容易把握
加解密速度快
```
2. 缺点
```
收发双方持有相同密钥，Ke=Kd，密钥分发困难，在网络环境更突出
不能方便地实现数字签名，商业等应用也不方便
```
### 公开密钥密码的基本思想 
1. 将密钥K一分为二：Ke和Kd。Ke专门加密，Kd专门解密，且Ke与Kd不相等
2. 由Ke不能计算出Kd，于是可以将Ke公开，使密钥Ke分配简单
3. 由于Ke与Kd不相等且由Ke不能计算出Kd，所以Kd可以作为用户的指纹，方便地实现数字签名
 
### 公开密钥密码的基本条件
 E()和D()分别是加密和解密算法
 1. 保密条件： D和E互逆，即D(E(M))=M
 2. 安全条件：Ke与Kd不相等且由Ke不能计算出Kd
 3. 实用条件：E和D都高效
 4. 保真条件：E(D(M))=M  
 
 满足条件1、2、3可以用于保密；
 满足条件2、3、4可以用于保真（数字签名）；
 四个条件同时满足即可用于保密和保真
 
 ### 公钥密码的理论模型
 1.单向函数：y=f(x)需要满足以下两个函数
 ```
· 如果对于给定的x，计算y=f(x)很容易
· 对于给定的y，要计算出x=f^-1(y)很难
```
 2.利用单向函数构造密码
 ```
· 用正变换做加密，加密效率高
· 用逆变换做解密，安全，攻击者不可破译
· 但是合法的收信者也无法解密
``` 
 3.单向陷门函数
 
 设函数y=f(x)且f具有陷门，满足以下两个条件称f(x)的单向陷门函数
 ```
· 如果对于给定的x，计算出y=f(x)很容易
· 对于给定的y，如果不掌握陷门要计算出x很困难；如果掌握了陷门要计算出x很容易
```
4.利用单向陷门函数构造密码
```
· 用正变换做加密，加密效率高
· 用逆变换做解密，安全
· 把陷门作为密钥，且只分配给合法用户。确保合法用户能够方便解密，而非法用户不能破译
```
5.单向函数的研究现状

理论上，不能证明单向函数一定存在

实际上， 密码学认为之哟啊函数的单向性足够应用就行 

已知单向性足够的函数：
```
· 大合数的因式分解问题
· 有限域上的离散对数问题
· 椭圆曲线离散对数问题
```
## 公钥密码的基本工作方式
· 设M为明文，C为密文，E为加密算法，D为解密算法

· 每个用户都配置一对密钥Ke（公开的加密密钥）和Kd（保密的解密密钥）

· 将所有哦用户的公开加密密钥Ke存入共享的密钥数据库PKDB

· 保密的解密密钥Kd由用户妥善保管

1.确保数据的秘密性：
```
发送方：
    1.A查找PKDB（公钥数据库），找到B的公开密钥KeB
    2.A用KeB加密密文M得到密文C：C=E(M,KeB)
    3.A将C发送给B
接收方：
    1.B接收C
    2.B用自己的KdB解密，得到明文M=D(C,KdB)
```
安全性分析：保证了数据的秘密性，但是不确保数据的真实性，保密但是不保真

2.确保数据的真实性：
```
发送方：
    1.A用自己的KdA对M进行解密，得到C=D(M,KdA)
    2.A将C发送给B
接收方：
    1.B接收C
    2.B通过PKDB查询A的公开加密密钥KeA
    3.B使用KeA加密C，得到明文M=(C,KeA)
``` 
安全性分析：保证了真实性，但是不确保数据的秘密性，保真但是不保密

3.确保秘密性与真实性
```
发送方：
    1.A首先用KdA对M解密，得到中间密文S
    2.A查PKDB，得到B的KeB
    3.用Keb对S进行加密得到C
接收方：
    1.B接收C
    2.B用自己的KdB解密C得到中间密文S
    3.B查PKDB，得到A的KeA
    4.用KeA对密文S进行加密得到明文M
```
安全性分析：保证了真实性与秘密性


## 欧几里得和扩展欧几里得

欧几里得：辗转相除法

```
int gcd(int a,int b)
{
    return b==0?a:gcd(b,a%b);
}
```

扩展欧几里得：
	
	贝祖定理：如果a、b是整数，那么一定存在整数x、y使得ax+by=gcd(a,b)。
	
	有一个直接的应用就是 如果ax+by=1有解，那么gcd(a,b)=1。
	
	所以扩展欧几里得不光要找到a,b的最大公约数还要找到满足ax+by=gcd(a,b)的x和y。
	
```
int exgcd(int a,int b,int &x,int &y)//扩展欧几里得算法
{
    if(b==0)
    {
        x=1;y=0;
        return a;  //到达递归边界开始向上一层返回
    }
    int r=exgcd(b,a%b,x,y);
    int temp=y;    //把x y变成上一层的
    y=x-(a/b)*y;
    x=temp;
    return r;     //得到a b的最大公因数

}
```

数学归纳法证明：

	假设当前我们在求的时a和b的最大公约数，而我们已经求出了下一个状态：b和a%b的最大公因数，并且求出了一组x1和y1使得 b*x1+(a%b)*y1=gcd
	这时我们可以试着去寻找这两个相邻状态的关系：

	首先我们知道：a%b=a-(a/b)*b；带入：//注意这里的除法为整除

	b*x1 + (a-(a/b)*b)*y1

	= b*x1 + a*y1 – (a/b)*b*y1

	= a*y1 + b*(x1 – a/b*y1) = gcd   发现 x = y1 , y = x1 – a/b*y1

	这样我们就得到了每两个相邻状态的x和y的转化，就可以在求gcd的同时对x和y进行求值了


## ElGamal
建立在离散对数问题的基础上
· 随机选择一个大素数p，要求（p-1）具有大素数因子。选择一个模p
的本原根a，并且公开a和p作为密码的基础参数

· 用户随机生成一个正整数d，2≤d≤p-2，作为私钥

· 用户计算 y=a^d mod p 得出公钥y
 
### 加密
将明文M（0≤M≤p-1）加密成密文的过程如下：

· 随机的选取一个整数k，2≤k≤p-2

· 计算
```
U = y^k mod p    //y是公钥
C1 = a^k mod p
C2 = UM mod p
```
· 取C=（C1，C2）作为密文
### 解密
将密文（C1,C2）解密过程如下：
```
V = C1^d mod p
M = C2*(V^-1) mod p
```
 得到明文M

### 安全性
· 安全性建立在GF(p)离散对数的困难性之上

· 为了安全考量，p应该在150位以上的十进制数，且(p-1)应该有大素数因子

· d和k都不能太小

· 安全加密和签名所使用的k都必须是一次性的

## Diffie-Hellman密钥交换
· 目的是使两个用户可以安全地交换密钥，以便在后续的通信中使用该密钥进行消息加密

· 算法有效性建立在离散对数问题求解的困难性上

· 对素数p的本原根a求幂，实现范围从1到p-1的一个置换

### D-H密钥交换算法
· 存在两个公开的整数：素数q和本原根a

· 用户A随机选择一个整数 XA<q 并计算 YA=a^(XA) mod q

· 用户B也独立选择一个随机整数 XB<q 并计算 YB=a^(XB) mod q

· A和B保持各自的X是私有的，但是对另一方公开Y

· 用户A计算 K=(YB)^(XA) mod q，并将其作为密钥

· 用户B计算 K=(YA)^(XB) mod q，并将其作为密钥

最终两个K的计算结果是相同的，也就完成了密钥的确定过程。

```
KA =(YB)^(XA)mod q
   =(a^(XB)mod q)^(XA)mod q
   =(a^(XB))^(XA)mod q
KB =(YA)^(XB)mod q
   =(a^(XA)mod q)^(XB)mod q
   =(a^(XA))^(XB)mod q
   =(a^(XB))^(XA)mod q = KA 
```
## 椭圆曲线

### 椭圆曲线的定义

### 椭圆曲线的算数
```
E : Y^2= X^3 + AX + B

be an elliptic curve and let P1 and P2 be points on E.

(a) If P1 = O, then P1 + P2 = P2.

(b) Otherwise, if P2 = O, then P1 + P2 = P1.

(c) Otherwise, write P1 = (x1, y1) and P2 = (x2, y2).

(d) If x1 = x2 and y1 = −y2, then P1 + P2 = O.

(e) Otherwise, define λ by
    
    if P1=P2, then λ=(y2-y1)/(x2-x1)
    if P1≠P2, then λ=(3*x1^2+A)/(2*y1)

then let

x3 = λ^2 − x1 − x2 and y3 = λ(x1 − x3) − y1.

Then P1 + P2 = (x3, y3).
```

### 椭圆曲线困难问题 
####椭圆曲线离散对数问题ECDLP
给出椭圆曲线上的两点P和Q，求解以P为底Q的对数k
#### ECDLP求解
大步小步法
### 椭圆曲线的安全性
椭圆曲线密码的困难性建立在椭圆曲线对数求解问题之上。Pollar rho方法是目前已知最快的椭圆曲线对数求解方法。已知的是，ECC使用的密钥长度比RSA中使用的密钥长度短得多。而且在密钥长度相同时，ECC与RSA执行所需的计算量相差不多。因此，在具有相同安全性的情况下，ECC使用的密钥比RSA更短，计算量也比RSA更少。


